#pragma once

#include <iostream>
#include <fstream>
#include <cassert>
#include <cstring>
#include <cmath>

#include "type_convention.hpp"
#include "dger.hpp"
#include "dsyr.hpp"
#include "dsyrk.hpp"
#include "dgees.hpp"

class SchurAngularFactor
{
public:
    ColMat<REAL_TYPE> svec;
    REAL_TYPE *v; // n x n orthogonal Schur vectors stored in column major.
    REAL_TYPE *a; // div(n, 2) angles with nonzero store in the front of the vector.
    INTE_TYPE d;
    INTE_TYPE asize;
    INTE_TYPE nzsize;

    ColMat<CMPX_TYPE> zvec;
    CMPX_TYPE *tau;

    REAL_TYPE *w; // Workspace in (d + 2) * d size that is requried for performing the Schur decomposition and the recovery of SkewSymmMat or SpecOrthMat, which need d * d space.
    BOOL_TYPE ow; // Ownership of the workspace
                  // A nontrivial SchurAngularFactor must be assigned with a workspace, either
                  // provided by users, or allocates it by itself.

    SchurAngularFactor()
    {
        svec = ColMat<REAL_TYPE>();
        zvec = ColMat<CMPX_TYPE>();
        tau = nullptr;
        v = svec.v;
        a = nullptr;
        d = 0;
        asize = 0;
        nzsize = 0;
        w = nullptr;
        ow = true;
    };
    SchurAngularFactor(INTE_TYPE dim) : svec(ColMat<REAL_TYPE>(dim, dim)), zvec(ColMat<CMPX_TYPE>(dim, dim)), tau(new CMPX_TYPE[dim - 1]),
                                        v(svec.v), a(new REAL_TYPE[dim / 2]), d(dim), asize(dim / 2), w(nullptr)
    {
        nzsize = 0;
        svec.fast_col_access();
        zvec.fast_col_access();
        this->initial_workspace();
    };

    SchurAngularFactor(INTE_TYPE dim, REAL_TYPE *work) : svec(ColMat<REAL_TYPE>(dim, dim)), zvec(ColMat<CMPX_TYPE>(dim, dim)), tau(new CMPX_TYPE[dim - 1]),
                                                         v(svec.v), a(new REAL_TYPE[dim / 2]), d(dim), asize(dim / 2), w(work), ow(false)
    {
        nzsize = 0;
        svec.fast_col_access();
        zvec.fast_col_access();
    };
    void copy(const SchurAngularFactor &src)
    {

        // assert(this->d = src.d);
        // assert(this->asize = src.asize);

        this->nzsize = src.nzsize;
        this->svec.copy(src.svec);
        this->zvec.copy(src.zvec);
        std::memcpy(this->a, src.a, this->asize * sizeof(REAL_TYPE));

        if ((this->w && this->ow) && (!src.ow || !src.w))
            this->release_workspace();

        if (src.w)
            if (src.ow) // Deep copy
            {
                this->initial_workspace();
                memcpy(this->w, src.w, sizeof(REAL_TYPE) * 2 * src.d);
            }
            else // Shallow copy
            {
                this->w = src.w;
            }
        else
            this->w = nullptr;
    }
    SchurAngularFactor(const SchurAngularFactor &src) : SchurAngularFactor(src.d)
    {
        copy(src);
    }
    ~SchurAngularFactor()
    {
        if (a)
            delete[] a;
        a = nullptr;
        v = nullptr;
        if (ow && w)
            delete[] w;
        w = nullptr;
        delete[] tau;
        tau = nullptr;
    };
    void swap(SchurAngularFactor &rhs)
    {
        using std::swap;
        // swap(this->svec, rhs.svec);
        this->svec.swap(rhs.svec);

        swap(this->v, rhs.v);
        swap(this->a, rhs.a);
        swap(this->d, rhs.d);
        swap(this->asize, rhs.asize);
        swap(this->nzsize, rhs.nzsize);
        swap(this->w, rhs.w);
        swap(this->ow, rhs.ow);
    };
    SchurAngularFactor &operator=(const SchurAngularFactor &rhs)
    {
        SchurAngularFactor temp(rhs);
        swap(temp);
        return (*this);
    };

    BOOL_TYPE is_empty() const { return (a == nullptr); };

    void initial_workspace()
    {
        if (!w)
        {
            w = new REAL_TYPE[(d + 2) * d];
            ow = true;
        }
    }
    void release_workspace()
    {
        if (ow && w)
            delete[] w;
        w = nullptr;
        ow = false;
    }
    void set_workspace(REAL_TYPE *work)
    {
        // External workspace MUST be manage explictly by the user.
        // DO NOT reset workspace with workspace generated by the SAF object, as its ownership info is lost in the reset process.

        if (ow && (w != work))
            release_workspace();
        w = work;
        ow = false;
    }

    void compute_SkewSymmMat(REAL_TYPE *S, const INTE_TYPE lds);
    void compute_SkewSymmMat(REAL_TYPE *S) { compute_SkewSymmMat(S, this->d); };
    void compute_SkewSymmMat(const View_ColMat<REAL_TYPE> &ViewS) { compute_SkewSymmMat(ViewS.v, ViewS.ld); };
    void compute_SkewSymmMat(ColMat<REAL_TYPE> &MatS) { compute_SkewSymmMat(MatS.v, MatS.r); };

    void compute_SpecOrthMat(REAL_TYPE *S, const INTE_TYPE lds, REAL_TYPE *work);
    void compute_SpecOrthMat(REAL_TYPE *S, REAL_TYPE *work) { compute_SpecOrthMat(S, this->d, work); };
    void compute_SpecOrthMat(const View_ColMat<REAL_TYPE> &ViewS, REAL_TYPE *work) { compute_SpecOrthMat(ViewS.v, ViewS.ld, work); };
    void compute_SpecOrthMat(ColMat<REAL_TYPE> &MatS, REAL_TYPE *work) { compute_SpecOrthMat(MatS.v, MatS.r, work); };
    // The efficient implementation of compute_SpecOrthMat require an extra d x d work space.
    // The implementation will apply for one itself, as follows, if the workspace is not provided.

    void compute_SpecOrthMat(REAL_TYPE *S, INTE_TYPE lds) { compute_SpecOrthMat(S, lds, w); };
    void compute_SpecOrthMat(REAL_TYPE *S) { compute_SpecOrthMat(S, this->d); };
    void compute_SpecOrthMat(const View_ColMat<REAL_TYPE> &ViewS) { compute_SpecOrthMat(ViewS.v, ViewS.ld); };
    void compute_SpecOrthMat(ColMat<REAL_TYPE> &MatS) { compute_SpecOrthMat(MatS.v, MatS.r); };

    friend REAL_TYPE *generate_Workspace(const SchurAngularFactor *scf)
    {
        return new REAL_TYPE[scf->d * (scf->d * 2)];
    }

    friend REAL_TYPE *generate_Workspace(const SchurAngularFactor *scf, INTE_TYPE d)
    {
        return new REAL_TYPE[d * (d + 2)];
    }

    void assign(const REAL_TYPE *x, INTE_TYPE ldx)
    {
        auto src_ptr = x;
        auto des_ptr = w;
        if (ldx == d)
            memcpy(des_ptr, src_ptr, sizeof(REAL_TYPE) * d * d);
        else
            for (INTE_TYPE col_ind = 0; col_ind < d; col_ind++, src_ptr += ldx, des_ptr += d)
                memcpy(des_ptr, src_ptr, sizeof(REAL_TYPE) * d);
    }
    void assign(const ColMat<REAL_TYPE> &MatX) { memcpy(w, MatX.v, sizeof(REAL_TYPE) * d * d); };
    void assign(const View_ColMat<REAL_TYPE> &ViewX) { assign(ViewX.v, ViewX.ld); };

    void SchurAngular_SpecOrth();
    void SchurAngular_SpecOrth(const REAL_TYPE *x, INTE_TYPE ldx)
    {
        assign(x, ldx);
        SchurAngular_SpecOrth();
    };
    void SchurAngular_SpecOrth(const ColMat<REAL_TYPE> &MatX)
    {
        assign(MatX);
        SchurAngular_SpecOrth();
    };
    void SchurAngular_SpecOrth(const View_ColMat<REAL_TYPE> &ViewX)
    {
        assign(ViewX);
        SchurAngular_SpecOrth();
    };

    void printf()
    {
        std::printf("Schur vectors:\n");
        svec.printf();
        std::printf("Angles:\n");
        for (INTE_TYPE i = 0; i < asize; i++)
            if (i < nzsize)
                std::printf("%1.3f\t", a[i]);
            else
                std::printf("0\t");
        std::printf("\n\n");
    }
};